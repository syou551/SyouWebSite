import * as dntShim from "../../../../../../_dnt.shims.js";
import { bold, brightBlue, cyan, green, red, yellow } from "../deps.js";
import { ValidationError } from "../_errors.js";
import { Table } from "../../table/table.js";
export class Provider {
    constructor() {
        Object.defineProperty(this, "maxListSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 25
        });
        Object.defineProperty(this, "maxCols", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 8
        });
    }
    async isOutdated(name, currentVersion, targetVersion) {
        const { latest, versions } = await this.getVersions(name);
        if (targetVersion === "latest") {
            targetVersion = latest;
        }
        // Check if requested version exists.
        if (targetVersion && !versions.includes(targetVersion)) {
            throw new ValidationError(`The provided version ${bold(red(targetVersion))} is not found.\n\n    ${cyan(`Visit ${brightBlue(this.getRepositoryUrl(name))} for available releases or run again with the ${(yellow("-l"))} or ${(yellow("--list-versions"))} command.`)}`);
        }
        // Check if requested version is already the latest available version.
        if (latest && latest === currentVersion && latest === targetVersion) {
            console.warn(yellow(`You're already using the latest available version ${currentVersion} of ${name}.`));
            return false;
        }
        // Check if requested version is already installed.
        if (targetVersion && currentVersion === targetVersion) {
            console.warn(yellow(`You're already using version ${currentVersion} of ${name}.`));
            return false;
        }
        return true;
    }
    async upgrade({ name, from, to, importMap, main = `${name}.ts`, args = [] }) {
        if (to === "latest") {
            const { latest } = await this.getVersions(name);
            to = latest;
        }
        const registry = new URL(main, this.getRegistryUrl(name, to)).href;
        const cmd = [dntShim.Deno.execPath(), "install"];
        if (importMap) {
            const importJson = new URL(importMap, this.getRegistryUrl(name, to)).href;
            cmd.push("--import-map", importJson);
        }
        if (args.length) {
            cmd.push(...args, "--force", "--name", name, registry);
        }
        else {
            cmd.push("--no-check", "--quiet", "--force", "--name", name, registry);
        }
        const process = dntShim.Deno.run({ cmd, stdout: "piped", stderr: "piped" });
        const [status, stderr] = await Promise.all([
            process.status(),
            process.stderrOutput(),
            process.output(),
        ]);
        if (!status.success) {
            process.close();
            await dntShim.Deno.stderr.write(stderr);
            throw new Error(`Failed to upgrade ${name} from ${from} to version ${to}!`);
        }
        process.close();
        console.info(`Successfully upgraded ${name} from ${from} to version ${to}! (${this.getRegistryUrl(name, to)})`);
    }
    async listVersions(name, currentVersion) {
        const { versions } = await this.getVersions(name);
        this.printVersions(versions, currentVersion);
    }
    printVersions(versions, currentVersion, { maxCols = this.maxCols, indent = 0 } = {}) {
        versions = versions.slice();
        if (versions?.length) {
            versions = versions.map((version) => currentVersion && currentVersion === version
                ? green(`* ${version}`)
                : `  ${version}`);
            if (versions.length > this.maxListSize) {
                const table = new Table().indent(indent);
                const rowSize = Math.ceil(versions.length / maxCols);
                const colSize = Math.min(versions.length, maxCols);
                let versionIndex = 0;
                for (let colIndex = 0; colIndex < colSize; colIndex++) {
                    for (let rowIndex = 0; rowIndex < rowSize; rowIndex++) {
                        if (!table[rowIndex]) {
                            table[rowIndex] = [];
                        }
                        table[rowIndex][colIndex] = versions[versionIndex++];
                    }
                }
                console.log(table.toString());
            }
            else {
                console.log(versions.map((version) => " ".repeat(indent) + version).join("\n"));
            }
        }
    }
}
