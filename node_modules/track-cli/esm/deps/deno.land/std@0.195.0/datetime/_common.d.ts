export type Token = {
    type: string;
    value: string | number;
    index: number;
    [key: string]: unknown;
};
export interface ReceiverResult {
    [name: string]: string | number | unknown;
}
export type CallbackResult = {
    type: string;
    value: string | number;
    [key: string]: unknown;
};
type CallbackFunction = (value: unknown) => CallbackResult;
export type TestResult = {
    value: unknown;
    length: number;
} | undefined;
export type TestFunction = (string: string) => TestResult | undefined;
export interface Rule {
    test: TestFunction;
    fn: CallbackFunction;
}
export declare class Tokenizer {
    rules: Rule[];
    constructor(rules?: Rule[]);
    addRule(test: TestFunction, fn: CallbackFunction): Tokenizer;
    tokenize(string: string, receiver?: (token: Token) => ReceiverResult): ReceiverResult[];
}
type DateTimeFormatPartTypes = "day" | "dayPeriod" | "hour" | "literal" | "minute" | "month" | "second" | "timeZoneName" | "year" | "fractionalSecond";
interface DateTimeFormatPart {
    type: DateTimeFormatPartTypes;
    value: string;
}
type TimeZone = "UTC";
interface Options {
    timeZone?: TimeZone;
}
export declare class DateTimeFormatter {
    #private;
    constructor(formatString: string, rules?: Rule[]);
    format(date: Date, options?: Options): string;
    parseToParts(string: string): DateTimeFormatPart[];
    /** sort & filter dateTimeFormatPart */
    sortDateTimeFormatPart(parts: DateTimeFormatPart[]): DateTimeFormatPart[];
    partsToDate(parts: DateTimeFormatPart[]): Date;
    parse(string: string): Date;
}
export {};
