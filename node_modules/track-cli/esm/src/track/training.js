import { OtherError } from "../shared/errors.js";
import { HttpStatus } from "../shared/mod.js";
import { FormType, TrackClientBase, } from "./client.js";
// @ts-ignore: has no exported member
import { CookieJar, fetch } from "node-fetch-cookies";
export class TrainingClient extends TrackClientBase {
    constructor(baseUrl, orgName, token, courseMaterialId, klassId, klassResultId, basic, cookies) {
        super(baseUrl, basic, cookies, (res) => HttpStatus.isRedirect(res) || res.status === HttpStatus.Unauthorized);
        Object.defineProperty(this, "orgName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "token", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "courseMaterialId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "klassId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "klassResultId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.orgName = orgName;
        this.token = token;
        this.courseMaterialId = courseMaterialId;
        this.klassId = klassId;
        this.klassResultId = klassResultId;
    }
    config() {
        return {
            courseMaterialId: this.courseMaterialId,
            klassId: this.klassId,
            klassResultId: this.klassResultId,
        };
    }
    async authenticate() {
        this.cookies = new CookieJar();
        const authUrl = `${this.baseUrl}/${this.orgName}/train/${this.token}/challenges/${this.courseMaterialId}`;
        const res = await fetch(this.cookies, authUrl, {
            headers: this.headers,
            agent: this.agent,
        });
        if (!HttpStatus.isSuccess(res)) {
            throw new OtherError(`Failed to authenticate: ${res.status}\n${await res.text()}`);
        }
        const { klassId } = (await res.json()).result;
        this.klassId = klassId;
    }
    async startChallengeSession() {
        const trainingChallenge = await this._post(`/api/train/${this.klassId}/challenges/${this.courseMaterialId}`, FormType.JSON, {});
        this.klassResultId = trainingChallenge.result.klassResultId;
        return toChallengeSession(trainingChallenge);
    }
    continueChallengeSession() {
        return this.startChallengeSession();
    }
    async languages() {
        return (await this._get(`/cli/languages`))
            .map(toProgrammingLanguageInfo);
    }
    async start() {
        return await this._put(`/api/train/${this.klassId}/challenges/results/${this.klassResultId}/start`, FormType.JSON, {
            takenBy: 3, // 3 = LocalMachine
        });
    }
    prepare() {
        throw new OtherError("Unsupported operation");
    }
    async updateLanguage(language) {
        await this._put(`/api/train/${this.klassId}/challenges/results/${this.klassResultId}/lang`, FormType.JSON, {
            lang: language,
        });
    }
    async timeLeft() {
        return await this._get(`/api/train/${this.klassId}/challenges/results/${this.klassResultId}/timeleft`);
    }
    async context() {
        return await this._get(`/api/train/${this.klassId}/challenges/results/${this.klassResultId}/context`);
    }
    async presigned(files) {
        return await this._post(`/api/train/${this.klassId}/challenges/review/${this.klassResultId}/presigned`, FormType.JSON, {
            files: files,
        });
    }
    async orcaHost() {
        const asText = true;
        const editorHtml = await this._get("/editor/1.0/coding", asText);
        return (/data-orca-host="([^"]+)"/.exec(editorHtml) ||
            ["", "track-prod-frontend.orca.run"])[1];
    }
    async orcaToken(context) {
        return await this._get(context.urlForOrcaToken);
    }
    async saveFiles(files) {
        return await this._put(`/api/train/${this.klassId}/challenges/results/${this.klassResultId}/save`, FormType.JSON, files);
    }
    async updateEditorScore(score) {
        return await this._put(`/api/train/${this.klassId}/challenges/results/${this.klassResultId}/editorScore`, FormType.JSON, {
            editorScore: score,
        });
    }
    async reset() {
        return await this._put(`/api/train/${this.klassId}/challenges/results/${this.klassResultId}/reset`, FormType.JSON, {});
    }
}
function toChallengeSession(tcs) {
    return {
        challengeId: tcs.challenge.id,
        challengeVersionId: tcs.challenge.challengeVersionId,
        style: tcs.challenge.style,
        title: tcs.challenge.title,
        description: tcs.challenge.description,
        timeLimitMinutes: tcs.challenge.timeLimitMinutes,
        displayOrder: tcs.challenge.displayOrder,
        openTestcases: tcs.challenge.openTestcases,
        programmingLanguages: tcs.challenge.programmingLanguages,
        localCodingAllowed: tcs.challenge.localCodingEnabled,
        result: tcs.result,
    };
}
function toProgrammingLanguageInfo(pl) {
    return {
        value: pl.id,
        name: pl.name,
    };
}
