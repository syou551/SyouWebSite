import { ExamCanceled, ExamExpired, ExamSubmitted, ExamUnread, InvalidChallengeId, OtherError, } from "../shared/errors.js";
import { HttpStatus } from "../shared/mod.js";
import { ChallengeStyle, } from "../shared/types.js";
import { FormType, TrackClientBase, } from "./client.js";
// @ts-ignore: has no exported member
import { CookieJar, fetch } from "node-fetch-cookies";
export class TestClient extends TrackClientBase {
    constructor(baseUrl, orgName, token, challengeId, basic, cookies) {
        super(baseUrl, basic, cookies);
        Object.defineProperty(this, "orgName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "token", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "challengeId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "applicantExamId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "resultId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        this.orgName = orgName;
        this.token = token;
        this.challengeId = challengeId;
    }
    config() {
        return {
            challengeId: this.challengeId,
            applicantExamId: this.applicantExamId,
            challengeResultId: this.resultId,
        };
    }
    async authenticate() {
        this.cookies = new CookieJar();
        const authUrl = `${this.baseUrl}/${this.orgName}/exams/${this.token}`;
        const res = await fetch(this.cookies, authUrl, {
            headers: this.headers,
            agent: this.agent,
        });
        if (!HttpStatus.isSuccess(res)) {
            throw new OtherError(`Failed to authenticate: ${res.status}\n${await res.text()}`);
        }
    }
    async startChallengeSession() {
        const applicantExam = await this.getApplicantExamNoAuth();
        const webUrl = `${this.baseUrl}/${this.orgName}/exams/${this.token}`;
        this.ensureExamInProgress(applicantExam.status, webUrl);
        const examSession = await this.getExamSession(applicantExam.id);
        const result = examSession.results.find((r) => r.challengeId === this.challengeId);
        const challenge = this.getChallengeFromExamSession(examSession, result);
        if (!challenge) {
            throw new InvalidChallengeId(this.challengeId);
        }
        this.applicantExamId = applicantExam.id;
        this.resultId = result?.id || 0;
        return challenge;
    }
    async getApplicantExamNoAuth() {
        return await this._get(`/api/applicants/exams/${this.token}/min`);
    }
    ensureExamInProgress(status, webUrlRedirect) {
        switch (status) {
            case ApplicantExamStatus.Submitted:
            case ApplicantExamStatus.Reviewed:
                throw new ExamSubmitted();
            case ApplicantExamStatus.Expired:
                throw new ExamExpired();
            case ApplicantExamStatus.Canceled:
                throw new ExamCanceled();
            case ApplicantExamStatus.Unread:
                throw new ExamUnread(webUrlRedirect);
            case ApplicantExamStatus.InProgress:
                return;
        }
    }
    async getExamSession(applicantExamId) {
        return await this._get(`/api/applicants/exams/${applicantExamId}`);
    }
    getChallengeFromExamSession(examSession, result) {
        return examSession.challengesSets
            .flatMap((s) => s.challenges)
            .map((esc) => toChallengeSession(esc, result))
            .find((c) => c.challengeId === this.challengeId &&
            (c.style === ChallengeStyle.Development ||
                c.style === ChallengeStyle.Algorithm));
    }
    async languages() {
        return (await this._get(`/api/enum/challenges/programminglanguages`))
            .map(toProgrammingLanguageInfo);
    }
    async start() {
        return await this._put(`/api/applicants/exams/${this.applicantExamId}/results/${this.resultId}/start`, FormType.URLEncoded, {
            takenBy: 3, // 3 = LocalMachine
        });
    }
    async prepare() {
        return await this._post(`/api/applicants/exams/${this.applicantExamId}/results`, FormType.URLEncoded, {
            challengeId: this.challengeId,
        });
    }
    async updateLanguage(language) {
        return await this._put(`/api/applicants/exams/${this.applicantExamId}/results/${this.resultId}/language`, FormType.URLEncoded, {
            programmingLanguage: language,
        }); // ChallengeResult
    }
    async timeLeft() {
        return await this._get(`/api/applicants/exams/${this.applicantExamId}/results/${this.resultId}/timeleft`);
    }
    async context() {
        return await this._get(`/api/applicants/exams/${this.applicantExamId}/results/${this.resultId}/context`);
    }
    async presigned(files) {
        return await this._post(`/api/applicants/exams/${this.applicantExamId}/results/${this.resultId}/presigned`, FormType.JSON, {
            files: files,
        });
    }
    async orcaHost() {
        const asText = true;
        const editorHtml = await this._get("/editor/1.0/coding", asText);
        return (/data-orca-host="([^"]+)"/.exec(editorHtml) ||
            ["", "track-prod-frontend.orca.run"])[1];
    }
    async orcaToken(context) {
        return await this._get(context.urlForOrcaToken);
    }
    async saveFiles(files) {
        return await this._put(`/api/applicants/exams/${this.applicantExamId}/results/${this.resultId}/save`, FormType.JSON, files);
    }
    async updateEditorScore(score) {
        return await this._put(`/api/applicants/exams/${this.applicantExamId}/results/${this.resultId}/editorScore`, FormType.URLEncoded, {
            editorScore: score,
        });
    }
    async reset() {
        return await this._put(`/api/applicants/exams/${this.applicantExamId}/results/${this.resultId}/reset`, FormType.URLEncoded, {});
    }
}
const ApplicantExamStatus = {
    Unread: 1,
    InProgress: 2,
    Submitted: 3,
    Expired: 4,
    Canceled: 5,
    Reviewed: 6,
};
function toChallengeSession(esc, result) {
    return {
        challengeId: esc.id,
        challengeVersionId: esc.challengeVersionId,
        style: esc.style,
        title: esc.title,
        description: esc.description,
        timeLimitMinutes: esc.timeLimitMinutes,
        displayOrder: esc.displayOrder,
        programmingLanguages: esc.programmingLanguages,
        localCodingAllowed: esc.localExamEnabled,
        openTestcases: esc.openTestcases,
        result,
    };
}
function toProgrammingLanguageInfo(pl) {
    return {
        value: pl.value,
        name: pl.displayString,
    };
}
