import * as dntShim from "../../_dnt.shims.js";
import { load as loadConfig } from "../shared/config.js";
import { CantReadFile } from "../shared/errors.js";
import { getCommonChallengeContext, listFileNames, printTimeLeft, trackClientFromConfig, } from "../shared/mod.js";
import { EnvSettings, FileListType, } from "../shared/types.js";
import { OrcaClient } from "../orca/client.js";
import { FileType } from "../orca/types.js";
import * as colors from "../../deps/deno.land/std@0.195.0/fmt/colors.js";
import { exists } from "../../deps/deno.land/std@0.195.0/fs/mod.js";
import { FileNotFound } from "../shared/errors.js";
const MAX_MEMORY_FOR_TEST = 512 * 1024 * 1024; // 512 MB
export async function run(options) {
    const config = await loadConfig();
    const api = trackClientFromConfig(config);
    const [codingContext, challenge] = await getCommonChallengeContext(config, api);
    // const orcaHost = Deno.env.get("ORCA_HOST") || "track-prod-frontend.orca.run";
    // Temporary code to retrieve the Orca host. Will be able to get from CodingContext in the future.
    const orcaHost = codingContext.orcaHost || await api.orcaHost();
    const token = await api.orcaToken(codingContext);
    const orca = new OrcaClient(orcaHost, token);
    await orca.connect();
    const envConfig = codingContext.answers.envConfig || EnvSettings.default;
    await orca.prepare({
        imageName: envConfig.imageName,
        interactive: false,
        cacheDirs: envConfig.cacheDirs,
        username: envConfig.username,
        baseDir: envConfig.baseDir,
    });
    const envVars = Object.assign({}, envConfig.variables);
    envVars["CHALLENGE_LANGUAGE"] = codingContext.challengeLanguage;
    if (codingContext.answers.appCommand) {
        envVars["APP_COMMAND"] = codingContext.answers.appCommand;
    }
    await orca.envVars(envVars);
    const files = Object.entries(await getAllEditableFileContent(codingContext))
        .map(([name, content]) => ({
        name,
        content,
        type: FileType.UTF8,
    }));
    let saveFilesRequest;
    if (!options?.noSave) {
        const updatedFiles = await getAllEditableFileContent(codingContext);
        saveFilesRequest = {
            versionId: codingContext.challengeVersionId,
            addedFiles: codingContext.answers.addedFiles || [],
            updatedFiles: updatedFiles,
        };
        console.log("Saving challenge files");
        await api.saveFiles(saveFilesRequest);
        console.log(colors.green("Challenge files saved"));
    }
    console.log();
    console.log("Running Tests");
    console.log("-".repeat(50));
    console.log();
    let buildRan = false;
    const runId = dntShim.crypto.randomUUID();
    // Run the initialize/build commands if they exist
    let buildDoneData;
    if ((codingContext.answers.build?.length || 0) > 0 ||
        codingContext.settings.initialize.length > 0) {
        const shellCommand = []
            .concat(codingContext.settings.initialize)
            .concat(codingContext.answers.build || [])
            .filter((s) => s && s.length > 0);
        const runCmd = {
            id: `${runId}-build`,
            imageName: envConfig.imageName,
            workingDir: envConfig.workingDir ?? "",
            shellCmd: shellCommand.join(" && "),
            attachVolume: true,
            files,
            envVars: {},
            tarballUrls: codingContext.tarballUrls,
        };
        buildRan = true;
        buildDoneData = await orca.simpleRunCommand(runCmd);
    }
    // Run the actual command
    if (!buildDoneData || buildDoneData.exitCode === 0) {
        const runCmd = {
            id: `${runId}-run`,
            imageName: envConfig.imageName,
            workingDir: envConfig.workingDir ?? "",
            shellCmd: codingContext.settings.test,
            attachVolume: true,
            files: buildRan ? [] : files,
            envVars: {},
            tarballUrls: buildRan ? [] : codingContext.tarballUrls,
            memoryBytes: MAX_MEMORY_FOR_TEST,
        };
        const scoreCounter = new CountPassingLineHandler();
        const runDoneData = await orca.simpleRunCommand(runCmd, scoreCounter);
        console.log(`exit_code = ${runDoneData.exitCode}, reason = ${runDoneData.reason}`);
        console.log();
        console.log("Test Results");
        console.log("-".repeat(50));
        console.log();
        if (challenge.openTestcases) {
            const totalPassed = scoreCounter.totalPassed();
            const scoreStr = `${totalPassed}/${challenge.openTestcases}`;
            console.log(`Score: ${colors.green(scoreStr)}`);
            await api.updateEditorScore(totalPassed);
        }
        const timeLeft = await api.timeLeft();
        printTimeLeft(timeLeft);
    }
    else {
        console.log();
        console.log(colors.red("Build error!"));
    }
    // If we saved the files, print out the files we actually saved
    // and where the user can find them in the web editor
    if (saveFilesRequest) {
        const updatedDisplayFiles = Object.keys(saveFilesRequest.updatedFiles);
        updatedDisplayFiles.sort();
        console.log();
        console.log("Saved:");
        console.log();
        for (const file of updatedDisplayFiles) {
            console.log(colors.green(`\t${file}`));
        }
        console.log(`Files uploaded successfully.`);
    }
}
async function getAllEditableFileContent(context) {
    const result = {};
    for (const filePath of listFileNames(context, FileListType.Editable)) {
        try {
            if (await exists(filePath)) {
                const fileStr = await dntShim.Deno.readFile(filePath);
                result[filePath] = new TextDecoder().decode(fileStr);
            }
            else {
                throw new FileNotFound(filePath);
            }
        }
        catch (e) {
            if (e instanceof FileNotFound) {
                throw e;
            }
            else {
                throw new CantReadFile(filePath);
            }
        }
    }
    return result;
}
class CountPassingLineHandler {
    constructor() {
        Object.defineProperty(this, "_totalPassed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_passPattern", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: /^ok \d+/
        });
    }
    totalPassed() {
        return this._totalPassed;
    }
    handleLine(line) {
        if (this._passPattern.test(line)) {
            this._totalPassed += 1;
        }
    }
}
