import * as dntShim from "../../_dnt.shims.js";
import { OtherError } from "../shared/errors.js";
import { SnakeCase } from "../shared/mod.js";
import { green, red } from "../../deps/deno.land/std@0.195.0/fmt/colors.js";
import { EventEmitter } from "eventemitter3";
import { ProxyAgent } from "proxy-agent";
import WebSocket from "ws";
const RE_TAP_OK = new RegExp("^ok \\d+ ");
const RE_TAP_NG = new RegExp("^not ok \\d+ ");
export class OrcaClient {
    constructor(hostname, token) {
        Object.defineProperty(this, "hostname", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: hostname
        });
        Object.defineProperty(this, "token", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: token
        });
        Object.defineProperty(this, "socket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "eventEmitter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventEmitter()
        });
    }
    connect() {
        return new Promise((res, _rej) => {
            const scheme = this.hostname.startsWith("localhost") ? "ws://" : "wss://";
            const query = this.token ? `?token=${this.token}` : "";
            const url = `${scheme}${this.hostname}/socket${query}`;
            const options = { agent: new ProxyAgent() };
            const socket = new WebSocket(url, options);
            socket.onmessage = this.handleMessage.bind(this);
            socket.onopen = () => {
                console.log("WebSocket connection established");
                res();
                this.eventEmitter.emit("connect", url);
            };
            socket.onclose = (event) => {
                console.log(event);
                console.log(`WebSocket connection closed with code: ${event.code}`);
                this.eventEmitter.emit("disconnect", event.code);
            };
            this.socket = socket;
        });
    }
    handleMessage(event) {
        if (typeof event.data !== "string")
            return;
        const message = JSON.parse(event.data);
        const data = SnakeCase.from(message.data);
        switch (message.e) {
            case "stdout":
                this.handleStdOut(data);
                break;
            case "stderr":
                this.handleStdErr(data);
                break;
            case "cmd_done":
                this.handleCommandDone(data);
                break;
            default:
                break;
        }
        this.eventEmitter.emit(message.e, data);
    }
    handleStdOut(data) {
        this.printCommandResultWithColor(data.l);
    }
    handleStdErr(data) {
        console.log(data.l);
    }
    handleCommandDone(data) {
        const reason = data.reason ? `: ${data.reason}` : "";
        console.log(`Command ${data.id} done with exit code ${data.exitCode}${reason}`);
    }
    printCommandResultWithColor(s) {
        const lines = s.split("\n");
        const encoder = new TextEncoder();
        function print(s, isLast = false) {
            if (isLast) {
                dntShim.Deno.stdout.write(encoder.encode(s));
            }
            else {
                dntShim.Deno.stdout.write(encoder.encode(s + "\n"));
            }
        }
        lines.forEach((line, i) => {
            const isLast = i === lines.length - 1;
            if (RE_TAP_OK.test(line)) {
                print(green(line), isLast);
            }
            else if (RE_TAP_NG.test(line)) {
                print(red(line), isLast);
            }
            else {
                print(line, isLast);
            }
        });
    }
    on(eventName, func) {
        this.eventEmitter.on(eventName, func);
    }
    off(eventName, func) {
        this.eventEmitter.off(eventName, func);
    }
    send(commandName, eventName, data, toSnakeCase = true) {
        return new Promise((res, rej) => {
            this.eventEmitter.once(eventName, (e) => {
                res(SnakeCase.from(e));
            });
            try {
                const d = toSnakeCase ? SnakeCase.to(data) : data;
                this.socket?.send(JSON.stringify({
                    e: commandName,
                    data: d,
                }));
            }
            catch (e) {
                rej(new OtherError(e.message));
            }
        });
    }
    prepare(request) {
        return this.send("prepare", "prepare_done", request);
    }
    envVars(envVars) {
        return this.send("env_vars", "env_vars_done", { env_vars: envVars }, false);
    }
    async simpleRunCommand(request, lineHandler) {
        const handler = lineHandler?.handleLine
            ? function (e) {
                e.l.split("\n").forEach((line) => lineHandler.handleLine(line));
            }
            : (() => { });
        this.on("stdout", handler);
        const result = await this.send("simple_run", "cmd_done", request);
        this.off("stdout", handler);
        return result;
    }
}
