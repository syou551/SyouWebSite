import * as dntShim from "../../_dnt.shims.js";
import { save as saveConfig, } from "./config.js";
import { BadTarballURL, ChallengeAlreadyFinished, OtherError, } from "./errors.js";
import { toNativeStyle, untgz } from "./file.js";
import { ChallengeResultStatus, FileListType, TrackApp, } from "./types.js";
import { TestClient } from "../track/test.js";
import { TrainingClient } from "../track/training.js";
import * as datetime from "../../deps/deno.land/std@0.195.0/datetime/mod.js";
import * as colors from "../../deps/deno.land/std@0.195.0/fmt/colors.js";
import { format as duration } from "../../deps/deno.land/std@0.195.0/fmt/duration.js";
import * as fs from "../../deps/deno.land/std@0.195.0/fs/mod.js";
import { exists } from "../../deps/deno.land/std@0.195.0/fs/mod.js";
export const _internals = {
    prompt: dntShim.prompt,
    scoreRatio: scoreRatio,
};
export const HttpStatus = {
    OK: 200,
    Unauthorized: 401,
    isSuccess(r) {
        const status = typeof r === "number" ? r : r.status;
        return 300 > status && status >= 200;
    },
    isRedirect(r) {
        const status = typeof r === "number" ? r : r.status;
        return 400 > status && status >= 300;
    },
    isClientError(r) {
        const status = typeof r === "number" ? r : r.status;
        return 500 > status && status >= 400;
    },
    isServerError(r) {
        const status = typeof r === "number" ? r : r.status;
        return 600 > status && status >= 500;
    },
};
export const Prompt = {
    select(message, items) {
        const maxDigits = items.length.toString().length;
        // Writes lines like this, with padding:
        // [ 1] C++
        // [..] ...
        // [45] Golang
        const list = items
            .map((item, i) => `[${((i + 1) + "").padStart(maxDigits, " ")}] ${item}`)
            .join("\n");
        const answerStr = _internals.prompt(`${message}\n${list}\n> `);
        if (!answerStr) {
            return;
        }
        const answer = parseInt(answerStr);
        if (answer > 0 && answer <= items.length) {
            return answer - 1;
        }
        else {
            return;
        }
    },
};
export function printTimeLeft(timeLeftSeconds) {
    const durationMessage = duration(timeLeftSeconds * 1000, { ignoreZero: true }) || "0s";
    if (timeLeftSeconds > 300) {
        console.log(`Time left: ${colors.yellow(durationMessage)}`);
    }
    else if (timeLeftSeconds >= 0) {
        const isWindows = dntShim.Deno.build.os === "windows";
        const warningSymbol = isWindows ? "!" : "⚠️";
        console.log(`Time left: ${warningSymbol}    ${colors.red(durationMessage)}    ${warningSymbol}`);
    }
    else if (timeLeftSeconds === -1) {
        console.log("The exam deadline has not yet been started");
    }
    else {
        console.log("The exam deadline has passed");
    }
}
export async function tryStartingChallenge(api, challenge) {
    let result = challenge.result;
    while (true) {
        if (result) {
            switch (result.status) {
                case ChallengeResultStatus.Prepared:
                case ChallengeResultStatus.CanRestart: {
                    const timeMsg = typeof challenge.timeLimitMinutes === "number"
                        ? `You have ${challenge.timeLimitMinutes} minutes to complete this challenge.`
                        : `This challenge has no time limit.`;
                    const wariningMsg = challenge.programmingLanguages.length === 0
                        ? `The challenge will start after this point.\n${timeMsg}`
                        : `The challenge will start after you select a programming language in the next step.\n${timeMsg}`;
                    console.log(wariningMsg);
                    const shouldContinue = dntShim.confirm("Do you want to continue?");
                    if (!shouldContinue) {
                        throw new OtherError("Aborted. Challenge was not started.");
                    }
                    if (challenge.programmingLanguages.length > 0) {
                        const programmingLanguages = (await api.languages())
                            .filter((pl) => challenge.programmingLanguages.includes(pl.value));
                        const desiredLanguage = chooseProgrammingLanguage(programmingLanguages);
                        if (desiredLanguage.value !== result.programmingLanguage) {
                            await api.updateLanguage(desiredLanguage.value);
                        }
                    }
                    result = await api.start();
                    break;
                }
                case ChallengeResultStatus.Started:
                    console.log("Challenge is started.");
                    return result;
                case ChallengeResultStatus.InProgress:
                    console.log("Challenge is in progress!");
                    return result;
                case ChallengeResultStatus.Finished:
                case ChallengeResultStatus.NotModified:
                case ChallengeResultStatus.ScoringWaiting:
                    throw new ChallengeAlreadyFinished();
            }
        }
        else {
            // Challenge hasn't been prepared yet
            result = await api.prepare();
        }
    }
}
export function chooseProgrammingLanguage(languages) {
    while (true) {
        const desiredLanguageIndex = Prompt.select("Please select a programming language:", languages.map((l) => l.name));
        if (desiredLanguageIndex !== undefined) {
            return languages[desiredLanguageIndex];
        }
        else {
            console.log("An invalid programming language was specified");
        }
    }
}
function filePaths(settings, fileListType) {
    const files = [];
    function addFiles(path, fileTree) {
        for (const [name, entry] of Object.entries(fileTree)) {
            const relativePath = path.length === 0 ? name : `${path}/${name}`;
            if (typeof entry === "boolean") { // file
                const editable = entry;
                switch (fileListType) {
                    case FileListType.All:
                        files.push(relativePath);
                        break;
                    case FileListType.ReadOnlyChallengeFiles:
                        if (!editable) {
                            files.push(relativePath);
                        }
                        break;
                    case FileListType.EditableChallengeFiles:
                    case FileListType.Editable:
                        if (editable) {
                            files.push(relativePath);
                        }
                        break;
                    case FileListType.UserAddedFiles:
                        break;
                }
            }
            else { // directory
                addFiles(relativePath, entry);
            }
        }
    }
    addFiles("", settings.files);
    return files;
}
export function listFileNames(context, fileListType) {
    const allFiles = new Set(filePaths(context.settings, fileListType));
    const addedFiles = context.answers.addedFiles;
    switch (fileListType) {
        case FileListType.All:
        case FileListType.Editable:
        case FileListType.UserAddedFiles:
            addedFiles?.forEach((f) => allFiles.add(f));
            break;
    }
    return Array.from(allFiles);
}
export const SnakeCase = {
    to(obj) {
        const type = typeof obj;
        switch (type) {
            case "string":
                return obj.replace(/([A-Z])/g, "_$1").toLowerCase();
            case "object": {
                if (obj instanceof Array) {
                    return obj;
                }
                else if (obj === null) {
                    return obj;
                }
                const newObj = {};
                for (const [key, value] of Object.entries(obj)) {
                    newObj[this.to(key)] = typeof value === "string"
                        ? value
                        : this.to(value);
                }
                return newObj;
            }
            default:
                return obj;
        }
    },
    from(obj) {
        const type = typeof obj;
        switch (type) {
            case "string":
                return obj.replace(/(_\w)/g, (m) => m[1].toUpperCase());
            case "object": {
                if (obj instanceof Array) {
                    return obj;
                }
                else if (obj === null) {
                    return obj;
                }
                const newObj = {};
                for (const [key, value] of Object.entries(obj)) {
                    newObj[this.from(key)] = typeof value === "string"
                        ? value
                        : this.from(value);
                }
                return newObj;
            }
            default:
                return obj;
        }
    },
};
export async function getCommonChallengeContext(config, api) {
    const challenge = await api.startChallengeSession();
    if (!challenge.result) {
        throw new OtherError(`Challenge for challenge id ${challenge.challengeId} is missing - has the challenge been started yet?`);
    }
    const result = challenge.result;
    switch (result.status) {
        case ChallengeResultStatus.Finished:
        case ChallengeResultStatus.NotModified:
            throw new ChallengeAlreadyFinished();
        case ChallengeResultStatus.CanRestart: {
            console.log("This challenge can be restarted");
            console.log();
            const result2 = await tryStartingChallenge(api, challenge);
            if (!result2) {
                throw new OtherError("Expected to have a challenge result after preparing and starting");
            }
            break;
        }
    }
    const codingContext = await api.context();
    // TODO: 保存条件
    config.cookies = api.getCookies();
    await saveConfig(config);
    return [codingContext, challenge];
}
function scoreRatio(editorScore, openTestcases) {
    // @ts-expect-error: isFinite(undefined) === false, isFinite(0) === true. See MDN
    if (isFinite(editorScore) && openTestcases) {
        return `\t${editorScore}/${openTestcases}`;
    }
    else {
        return "\tN/A - Use 'track run' to save and run your submission";
    }
}
export async function printChallengeInfo(api, codingContext, challenge) {
    // const { config, api, challengeResult: result } = trackContext;
    const result = challenge.result;
    const timeLeft = await api.timeLeft();
    printWorkingFileSet(codingContext);
    console.log();
    const lastScoredAt = result.lastScoredAt
        ? ` (Ran at ${datetime.format(new Date(result.lastScoredAt), "yyyy-MM-dd HH:mm:ss")})`
        : "";
    console.log(`Latest score${lastScoredAt}`);
    console.log(colors.green(scoreRatio(result.editorScore, challenge.openTestcases)));
    console.log();
    printTimeLeft(timeLeft);
}
export function printWorkingFileSet(codingContext) {
    console.log("Extra files included in your submission:");
    const userAddedFiles = listFileNames(codingContext, FileListType.UserAddedFiles);
    if (userAddedFiles.length > 0) {
        console.log("  (use 'track rm <file>' to remove files from your submission)");
        console.log();
        userAddedFiles.sort();
        userAddedFiles.forEach((f) => console.log(`\t${colors.green(toNativeStyle(f))}`));
    }
    else if (codingContext.settings.allowNewFile) {
        console.log();
        console.log("\tNo files currently added, use 'track add <file>' to add your own files to your submission");
        console.log();
    }
    else {
        console.log();
        console.log("\tThis challenge does not support adding new files");
        console.log();
    }
}
export async function downloadChallengeFilesTo(codingContext, dest, api, showFileDiff, includeTarball) {
    if (includeTarball) {
        console.log("Fetching challenge tarball...");
        const tarballResp = await dntShim.fetch(codingContext.tarballUrl);
        if (!HttpStatus.isSuccess(tarballResp.status)) {
            const statusReason = `${tarballResp.status} - ${tarballResp.statusText}`;
            throw new BadTarballURL(codingContext.tarballUrl, statusReason);
        }
        untgz(new Uint8Array(await (await tarballResp.blob()).arrayBuffer()), dest);
    }
    console.log("Downloading editable files");
    const filesToDownload = listFileNames(codingContext, FileListType.Editable);
    const presignedUrls = Object.entries(await api.presigned(filesToDownload))
        .map(([file, url]) => ({ file, url }));
    presignedUrls.sort((a, b) => a.file.localeCompare(b.file));
    const promises = presignedUrls.map(async ({ file, url }) => {
        const fileResp = await dntShim.fetch(url);
        const fileBody = new Uint8Array(await fileResp.arrayBuffer());
        const filePath = `${dest}/${file}`;
        if (!showFileDiff || !await fs.exists(file)) {
            await fs.ensureFile(filePath);
            await dntShim.Deno.writeFile(filePath, fileBody);
        }
        else {
            // TODO
        }
    });
    await Promise.all(promises);
}
export /**
 * Archives all files in a challenge directory into a subdirectory of
 * the challenge directory. Ignores .track/ and other existing archival directories
 */ async function archiveExistingChallengeFiles(orgName) {
    const challengeDir = dntShim.Deno.cwd();
    const base = `${orgName}_challenge_old`;
    let archiveDir;
    let i = 1;
    while (true) {
        archiveDir = `${base}_${i}`;
        const pathExists = await exists(archiveDir);
        if (pathExists) {
            i++;
            continue;
        }
        break;
    }
    console.log(`Your old challenge contents will be archived in ${archiveDir}`);
    await fs.ensureDir(archiveDir);
    const oldArchivePattern = /.*_challenge_old_\d+/;
    for await (const dirEntry of dntShim.Deno.readDir(challengeDir)) {
        if (dirEntry.name === archiveDir || dirEntry.name === ".track" ||
            (dirEntry.isDirectory && oldArchivePattern.test(dirEntry.name))) {
            continue;
        }
        await fs.move(`${challengeDir}/${dirEntry.name}`, `${archiveDir}/${dirEntry.name}`);
    }
}
export function trackClientFromConfig(config) {
    let api;
    switch (config.app) {
        case TrackApp.Test:
            api = new TestClient(config.baseUrl, config.orgName, config.token, config.challengeId, config.basicAuth, config.cookies);
            break;
        case TrackApp.Training:
            api = new TrainingClient(config.baseUrl, config.orgName, config.token, config.courseMaterialId, config.klassId, config.klassResultId, config.basicAuth, config.cookies);
            break;
        default:
            throw new OtherError(`Unsupported app: ${config.app}`);
    }
    return api;
}
