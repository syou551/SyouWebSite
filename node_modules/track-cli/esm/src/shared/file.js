import * as dntShim from "../../_dnt.shims.js";
import * as path from "../../deps/deno.land/std@0.195.0/path/mod.js";
import { Foras, gunzip } from "@hazae41/foras";
import tar from "tar";
import * as fs from "../../deps/deno.land/std@0.195.0/fs/mod.js";
export const _internals = {
    SEP: path.SEP,
};
/**
 * Given a user-supplied Vec of file paths, this function will
 * iterate over each one, optionally verify it exists, and optionally recursively
 * add files in subdirectories if the supplied path is a directory
 * It will also transform the path to be relative to the working directory
 */
export async function pathsToFilenameSet(paths, options) {
    const files = [];
    const root = options?.root ?? dntShim.Deno.cwd();
    for (const p of paths.map((p) => path.resolve(root, p))) {
        const f = await stat(p);
        const rp = toNixStyle(path.relative(root, p));
        if (rp.startsWith("..")) {
            continue;
        }
        if (options?.recursive && f) {
            const dirFiles = await getAllDirFiles(p);
            dirFiles.forEach((file) => files.push(toNixStyle(path.relative(root, file))));
        }
        else if (f?.isFile) {
            files.push(rp);
        }
        else if (options?.allowNonExistent) {
            files.push(toNixStyle(path.relative(root, p)));
        }
    }
    return new Set(files);
}
export async function stat(p) {
    try {
        return await dntShim.Deno.stat(p);
    }
    catch (_e) {
        return null;
    }
}
export async function isEmptyDirectory(p) {
    const f = await stat(p);
    if (!f) {
        return false;
    }
    else if (!f.isDirectory) {
        return false;
    }
    else {
        for await (const _dirEntry of dntShim.Deno.readDir(p)) {
            return false;
        }
        return true;
    }
}
/**
 * Given a path, will return an array with all files and sub-files recursively.
 * If the given path is a file, just a Vec with the file will be returned.
 */
export async function getAllDirFiles(p) {
    const allPaths = [];
    async function addFilesRecursive(p) {
        const f = await stat(p);
        if (!f) {
            return [];
        }
        if (f.isDirectory) {
            for await (const dirEntry of dntShim.Deno.readDir(p)) {
                await addFilesRecursive(`${p}/${dirEntry.name}`);
            }
        }
        else {
            allPaths.push(p);
        }
        return allPaths;
    }
    await addFilesRecursive(p);
    return allPaths;
}
export function toNixStyle(p) {
    return p.replaceAll(/[\\\/]/g, "/");
}
export function toNativeStyle(p) {
    return p.replaceAll(/[\\\/]/g, _internals.SEP);
}
export async function untgz(compressed, dest) {
    Foras.initSyncBundledOnce();
    const decompressed = gunzip(compressed);
    const tmpTarFile = await dntShim.Deno.makeTempFile();
    await dntShim.Deno.writeFile(tmpTarFile, decompressed);
    await tar.x({
        file: tmpTarFile,
        cwd: dest,
    });
}
export async function getUniqueDirName(base, options) {
    let counter = 1;
    const root = options?.root ?? dntShim.Deno.cwd();
    let uniqueDirName;
    while (true) {
        uniqueDirName = `${base}_${counter}`;
        if (await fs.exists(`${root}/${uniqueDirName}`)) {
            counter++;
        }
        else {
            return uniqueDirName;
        }
    }
}
